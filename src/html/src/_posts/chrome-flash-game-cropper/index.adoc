---
title: Flashゲームをpopupで表示するChrome Extensionを作成する
description: DMMやスクウェアエニックスで配信されているFlashゲームをpopupで表示するChrome Extensionを作成する方法とpopup windowのリロード方法についての注意点について。
date: 2014-12-11
updated: 2015-04-17
tags: JavaScript, Chrome Extension
---

いくつかのFlashゲームをサイズ変更可能な`popup`で表示するGoogle Extensionを作成する。すべてのFlashゲームに対応するのは当然無理なので、ユーザの多そうなDMMとスクウェアエニックスの汎用的な処理で対応できそうなFlashゲームに絞って対応しました。

[IMPORTANT]
.Flash Game Cropper
https://github.com/hbsnow/flash-game-cropper

今回作成したファイルはGitHubで公開しています。練習用コードなのでGoogle Chromeのウェブストアには登録していませんが、ショートカットキーの変更などの機能は実装されているのでそれなりに実用的ではあるとおもいます。



[[action]]
== 二種類のアクション

Google Extensionには大きく分けると以下の二種類に分類できます。

* https://developer.chrome.com/extensions/pageAction[Page action]
* https://developer.chrome.com/extensions/browserAction[Browser action]

常時表示するタイプがBrowser action、特定ページのURLでのみアドレスバー内で表示されるのがPage actionで、どちらが優れているとかそういった比較するものではありません。

今回は対応するゲームはそのゲームを実行しているURLが決まっている、つまりExtensionを実行できるURLもそのURLに限定されるのでPage actionで作ることにします。ネット上には比較的Browser actionのサンプルのほうが多いので、慣れてないうちはBrowser actionのほうが作りやすいとおもいます。



[[manifest]]
== Manifest

Google Extensionには`manifest.json`が必須です。

`default_locale`がRecommendedになってるけど言語用のフォルダを作らないとエラーになるので、他言語対応する気がそもそもまったくないのであればいらないとおもいます。

[source,json]
----
{
  "manifest_version": 2,
  "name": "Flash Game Cropper",
  "version": "1.0.0",
  "description": "FLASHゲームをリサイズ可能な別ウィンドウで表示します。",
  "icons": {
  "16" : "images/icon_16.png",
  "48" : "images/icon_48.png",
  "128": "images/icon_128.png"
  },

  "permissions": [
  "tabs",
  "storage",
  "<all_urls>"
  ],

  "background": {
  "scripts": [
    "js/background.js"
  ],
  "persistent": false
  },

  "page_action": {
  "default_icon": "images/icon_19.png",
  "default_title": "Flash Game Cropper"
  },

  "options_page": "options/options.html",
  "content_security_policy": "script-src 'self' 'unsafe-eval'; object-src 'self'"
}
----

今回の`manifest.json`はこんな感じ。link:https://developer.chrome.com/extensions/declare_permissions[permissions]はAPIに必要になるpermissionsが書かれている。最初は何を指定していいかわからなくて困るところなんだけど、実際に作っていくと使うものはそれほど多くならないのでわかりにくいものではない。APIを見ながらその都度チェックするでもいいし、漏れがあってもデバック中に権限が足りませんという親切なエラーがでるのでそんなに問題にはなりません。エラーメッセージで検索すると直球の答えは簡単に見つかるはず。

URLの指定方法はlink:https://developer.chrome.com/extensions/match_patterns[Match Patterns]で確認できる。`captureVisibleTab`を使う予定だったので`<all_urls>`が指定されているんだけど、結局完成したときには使ってないので実際に使うのであれば変更しておいたほうがパフォーマンスがよくなったりするかもしれません。

`content_security_policy`に書かれているのはJavaScript内で`eval`を使用するための指定で、Lo-Dashなどのライブラリを使うときにも指定が必要になります。今回ライブラリは使っていないのですが`eval`を使ったので指定しています。



[[background]]
== background

backgroundで指定されたファイルはChromeの起動時に実行されます。`"persistent": false`とすると必要なときにだけ実行するようになるらしいので、先述したURLの指定のパフォーマンスの話はここで関係してきそうな感じがするんだけど、まったく調べてないので全然関係ないかもしれません。

[source,js]
----
chrome.tabs.onUpdated.addListener(function(tabId, changeInfo, tab) {
  if(changeInfo.status === 'complete') {
    GAME_DATA.forEach(function(element) {
      if(tab.url === element.url) {
        chrome.pageAction.show(tabId);
      }
    });
  }
});
----

page_actionの場合にはbackgroundから`chrome.pageAction.show`でアイコンを表示させる手間がかかるので、これが完全な初心者だとちょっとわかりにくい部分かもしれない。

アイコンがクリックされたときの動作は`chrome.pageAction.onClicked.addListener`で指定します。

[[insert-js]]
== JavaScriptを挿入する

指定されたページにJavaScriptを指定したい場合には`chrome.tabs.executeScript`を使います。

[source,js]
----
function setScript(tabId, js) {
  chrome.tabs.executeScript(tabId, {
  file: 'js/common.js'
  }, function() {
  if(Array.isArray(js)) {
    js.forEach(function(element) {
      chrome.tabs.executeScript(tabId, {
        file: element
      });
    });
  }
  });
}
----

JavaScriptのファイルが複数あって、例えば`element`で指定されたJavaScriptのファイルから`js/common.js`で使用された変数を使用したいような場合にはこのように使われる側を最初に読み込んでコールバックする必要があります。

CSSの挿入には`chrome.tabs.insertCSS`を使う。使い方は`chrome.tabs.executeScript`とほとんど同じです。

埋め込まれたJavaScriptとbackgroundとの受け渡しには、`chrome.runtime.onMessage.addListener`を使う。例えば`js/common.js`からbackgroundで動作する`background.js`にメッセージを渡したいときには以下のようにします。

[source,js]
----
// js/common.js
chrome.runtime.sendMessage({
  msg: 'Hello, world!'
});

// background.js
chrome.runtime.onMessage.addListener(function(request) {
  console.log(request.msg);
});
----



[[option-page]]
== オプションページ

`options_page`で指定されたページはChromeのExtension一覧で表示されているオプション部分からリンクされます。

設定の保存にはlink:https://developer.chrome.com/extensions/storage[chrome.storage]を使いました。chrome.storageはpermissionsに指定をすることで容量の限界(5MB)を越えることができるので、このような設定の保存の他にも色々使い道がありそう。

デフォルトの設定はbackgroundでインストール時に設定されるようにしています。

[source,js]
----
var HOTKEY = {
  hotkey : {...}
}
chrome.runtime.onInstalled.addListener(function(details){
  if(details.reason === 'install') {
    chrome.storage.local.set(HOTKEY);
  }
});
----

設定を呼び出すには第一引数に`key`を指定して、`chrome.storage.local.get`を使用します。

[source,js]
----
chrome.storage.local.get('hotkey', function(result) {
  console.log(result);
}
----

設定画面を作ってちょっと気になったのは、たかだか数バイトしかない設定を呼び出すだけなのに若干時間がかかることがあるったこと。何が原因なのかはわからなかったんだけども、設定画面を作るときに現在設定を表示するようなことをする場合にはちょっと意識したほうがいいかもしれない。



[[reload-popup]]
== createしたpopup windowのリロード

単純なリロードではいけない理由は`executeScript`や`insertCSS`で挿入したファイルがリロード時に実行されないことが理由です。

このアイディアにはlink:https://github.com/kazamidoly/kanpaniExtension[kazamidoly/kanpaniExtension]を参考にしました。

最初の実装は`F5`を押すとmessageとして`reload`を`background.js`に渡すという方法。

[source,js]
----
chrome.runtime.onMessage.addListener(function(request) {
  switch(request.id) {
    case 'reload':
      var queryInfo = {
        active: true,
        currentWindow: true
      }

      chrome.tabs.query(queryInfo, function(tabs) {
        createWindow(tabs[0].id);
      });
      break;
  }
});
----

簡単にまとめると既存の開いているpopup windowを閉じて、同じURLのpopup windowを再生成という流れです。これの何が一番ダメかというとリロードしたときにウィンドウ座標が変わるところ。

そもそも指定したURLで常にファイルを挿入してそれらのファイルを実行することができない理由は、popup windowでない状態のURLでは実行されてほしくないから。つまりこれを回避できれば、こんな複雑な方法を用いてウィンドウを再生成なんてする必要なんてない。それをどう解決するかというと、実に単純で、ウィンドウ化したときに状態を判別するクエリ文字列を与えてやればいい。

ウィンドウ化には開いているタブをそのまま利用してリロードが発生しないようにしているため、URLにクエリ文字列を付与するにはウィンドウ化のときにHistory APIの`pushState`を使ってURLを変更する必要があります。

[source,js]
----
chrome.tabs.executeScript(tab.id, {
  code: 'history.pushState(null, null, "?window=true");'
});
----

あとは`chrome.tabs.onUpdated.addListener`でイベントを取得して、挿入したいファイルを指定すればいいだけです。`pushState`でも問題なく発火します。



[[bibliography]]
== 参照文献

[bibliography]
* https://developer.chrome.com/extensions/manifest[Manifest File Format]
