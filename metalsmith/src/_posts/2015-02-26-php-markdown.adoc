---
title: PHPで使うMarkdownのパーサを変更した
date: 2015-02-26
updated: 2015-04-02
tags: PHP, Markdown
---

これまでPHPのときのMarkdownのパースにはParsedownを使っていたんだけども、ちょっと拡張がしにくい感じがしたので、Laravel5に移行するついでに拡張がしやすいらしいlink:https://github.com/cebe/markdown[markdown]に変更してみました。噂通り本当に色々と変更がしやすかったので今後はmarkdownを使うことが多くなりそう。

以下はLaravelで使う方法。



[[install]]
== インストール

`composer.json`の`require`に以下を追加する。

[source,json]
----
"require": {
  "cebe/markdown": "~1.0.1"
},
----

`composer update`でアップデートして終了。


[[add-class]]
== クラスの追加

`app\Classes\Markdown\MyMarkdown.php`を作成。

[source,php]
----
<?php namespace App\Classes\Markdown;

use cebe\markdown\GithubMarkdown;

class MyMarkdown extends GithubMarkdown {
    //
}
----

あとはここに追加していくだけ。



[[edit-fcb]]
== FencedCodeBlockの修正

使ってみて気になったのが、FencedCodeBlock内のTab文字がそのまま出力されてしまうところ。そもそもインデントでTab文字を使うなといわれてしまうとそれまでなんだけれども、すべてのエディタで自動変換してくれるとは限らないのでこれはパーサで変換してもらいたい。

[source,php]
----
protected function consumeFencedCode($lines, $current)
{
    $line = rtrim($lines[$current]);
    $fence = substr($line, 0, $pos = strrpos($line, $line[0]) + 1);
    $language = substr($line, $pos);
    $content = [];

    for ($i = $current + 1, $count = count($lines); $i < $count; $i++)
    {
        if (rtrim($line = $lines[$i]) !== $fence)
        {
            $content[] = strstr($line, "\t") ? str_replace("\t", '    ', $line) : $line;
        }
        else
        {
            break;
        }
    }

    $block = [
        'code',
        'content' => implode("\n", $content),
    ];

    if (!empty($language))
    {
        $block['language'] = $language;
    }

    return [$block, $i];
}
----

MarkdownではインデントがCodeBlockになるけれども、自分はFencedCodeBlock以外でコードを表記することは絶対にないのでそちらは修正していない。おそらく同じ処理がされているので使うのであればそちらも修正が必要になるはず。

シンタックスハイライトのために`<pre>`に独自の属性を追加しておく。

[source,php]
----
protected function renderCode($block)
{
    $class = isset($block['language']) ? ' class="language-' . $block['language'] . '"' : '';
    return '<pre prism>' . "<code$class>" . htmlspecialchars($block['content'] . "\n", ENT_NOQUOTES | ENT_SUBSTITUTE, 'UTF-8') . "</code></pre>\n";
}
----



[[generate-toc]]
== ページ内メニューを生成する

最初はJavaScriptでやろうかなと思っていたんだけど、このパーサであれば簡単にMarkdownからページ内メニューの生成ができそうだったのでサーバサイドでやることにした。

[source,php]
----
private $menu = [];
private $max_level = 7;

protected function renderHeadline($block)
{
    $level = intval($block['level']);

    // 最大レベルの調整
    if ($this->max_level > $level)
    {
        $this->max_level = $level;
    }

    $render = $this->renderAbsy($block['content']);

    // id出力用データ追加
    $html_id = $this->id_prefix . str_replace([' ', '#'], '_', mb_convert_kana(strip_tags($render), 'asK'));

    $tail = '';
    $count = 1;
    foreach ($this->menu as $value)
    {
        if ($html_id . $tail === $value[2])
        {
            $tail = "-{$count}";
            $count++;

            continue;
        }
    }

    $html_id .= $tail;

    $this->menu[] = [$level, $render, $html_id];

    $tag = 'h' . $block['level'];
    return "<$tag id=\"" . $html_id . "\">$render</$tag>\n";
}
----

フィールドに空の配列と、Markdown内で使用されているもっとも大きいHeadingのレベルを保存しておく変数を用意する。`renderHeadline`内でレベルを取得しつつ、`$menu`にHeadingのレベルとタイトルを追加していく。

[source,php]
----
public function createMenu($url = '')
{
    if (empty($this->menu))
    {
        return '';
    }

    $result = '<ol>';

    foreach ($this->menu as $value)
    {
        if ($value[0] === $this->max_level)
        {
            $href = "{$url}#{$value[2]}";
            $result .= "<li du-scrollspy=\"{$href}\"><a href=\"{$href}\" du-smooth-scroll>{$value[1]}</a></li>";
        }
    }

    $result .= '</ol>';

    return $result;
}
----

配列が空なら即リターン。中身があればもっとも大きいHeadingのレベルだけを抽出してリストにしています。
