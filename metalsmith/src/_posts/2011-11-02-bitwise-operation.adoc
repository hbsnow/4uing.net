---
title: JavaScriptでのビット演算
date: 2011-11-02
updated: 2015-06-09
tags: JavaScript
---

[[binary]]
== ビット演算と二進法

データの二進法で表現されたコンピュータの扱う情報の最小単位であるビットを直接操作するのがビット演算です。つまり二進数がどのようなものであるか理解していなければ、ビット演算を理解することはできないということになります。では、二進法というのは一体どのようなものでしょうか。

二進法は普段、生活で利用している十進法がどのようなものかを理解していればとても簡単なものであることがわかります。

例えば`2011`という数字は十進法では`(2 × 10^3^) + (0 × 10^2^) + (1 × 10^1^) + (1 × 10^0^)`と表すことができます。このとき桁を示すために使用される数、十進法の場合には10を基数と言います。

[cols="3,1,1,1,1"]
|===
|桁|4|3|2|1

a|基数^x^
a|10^3^
a|10^2^
a|10^1^
a|10^0^

|桁の数
|2
|0
|1
|1
|===


二進法ではこの計算で使用されている基数である10が2に置き換わっているというだけの単純なことなのです。二進法では、十進法で桁としている部分のことをビット列と言います。

ここで二進法では`1111`が十進法でいくつを表しているのか考えてみましょう。

[cols="3,1,1,1,1"]
|===
|ビット列|3|2|1|0

a|基数^x^
a|2^3^
a|2^2^
a|2^1^
a|2^0^

|列の数
|1
|1
|1
|1
|===

この表から`(1 × 2^3^) + (1 × 2^2^) + (1 × 2^1^) + (1 × 2^0^)`の解が十進法での数となることがわかります。答えは`15`です。

ビット演算はこの二進法で表現された`0`と`1`の数字を操作することです。また、ビット演算に使用される記号のことをビット演算子といいます。


[[logical-operation]]
== ビット演算における論理演算

- `&`
- `|`
- `^`
- `~`

これらのビット演算における論理演算について見てみましょう。

十進法での`15`と`9`を使って実際にどういった数値の変化をするのかを考えます。

[cols="2a,1,1,1,1,2,8a"]
|===
|ビット列|3|2|1|0|結果|説明

|`a`
|1
|1
|1
|1
|15
|変数`a`とする。

|`b`
|1
|0
|0
|1
|9
|変数`b`とする。


|`a & b`
|1
|0
|0
|1
|9
|どちらも1ならば1、そうでなければ0とする。

|`a \| b`
|1
|1
|1
|1
|15
|どちらかが1もしくは共に1ならば1、どちらも0ならば0とする。

|`a ^ b`
|0
|1
|1
|0
|6
|どちらかが1ならば1、どちらも0か1なら0とする。

|`~a`
|0
|1
|1
|0
|6
|0を1、1を0に反転する。
|===

JavaScriptのビット演算における論理演算は32ビット整数に変換されるため、否定演算を二度行うことでその値を整数に変換することができます。これはJavaScriptではよく使われる手法です。ただこの場合には文字列が含まれると処理されないことに注意しなければなりません。

[source,js]
----
console.log(~~123.4); // 123
console.log(~~-4);    // -4
console.log(~~-3.14); // -3
console.log(~~5px);   // これはダメ
----

JavaScriptは数値を64ビットの倍精度浮動小数点数として扱いますが、それに対してビット演算では符号付32ビットの整数に変換して適用されるということです。つまり、符号付32ビットの整数型に型変換が行われるということになります。

[source,js]
----
// 1が32個
var foo = parseInt("11111111111111111111111111111111",2); // 4294967295
console.log(~~foo); // -1
----

このように`parseInt()`では扱える整数であっても`~`を使う手法では扱えない数値が存在するため、場合によっては意図しない結果をまねくかもしれません。

しかし、32ビットであるにせよ上記の記述で`-1`という結果になってしまうのはおかしいとおもうはずです。これは最も左のビット列が符号を表していることが原因になっています。

[source,js]
----
// 1 が 31個、つまりこれが最大値
console.log(~~parseInt("1111111111111111111111111111111",2));  // 2147483647
// 符号を明示
console.log(~~parseInt("01111111111111111111111111111111",2)); // 2147483647
----



[[negativeminus]]
== 二進法での負の値

負の値がでてきましたので、負の値について考えてみましょう。まずは人間が負の二進数を入力する場合、普通にマイナスの符号を使うことができます。

[source,js]
----
parseInt("-1111",2); // -15
----


<p>しかしコンピュータでは負の値を内部的に2の補数によって表現しています。さて、2の補数とは一体なんでしょうか。</p>

[source,js]
----
console.log(~~parseInt("01111111111111111111111111111111",2)); // 2147483647
console.log(~~parseInt("11111111111111111111111111111111",2)); // これは何になる？
----

最も左のビット列の数値が符号を示しているならば、`0`が`1`に変われば`-2147483647`になると考えられます。ですがこの結果はその予想とは異なり`-1`となります。このように単純に考えることができない、ということを理解していればここでは問題ありません。



[[complement]]
== 1の補数と2の補数

補数とは、ある数が基準となる数になるために加える必要がある数のことです。

そしてx進法において、aを表現するのに必要な桁数をnとしたとき、xの補数は`x^n^-a`、x-1の補数は`x^n^-a-1`と定義されます。

例えば10進法で`29`の10の補数は`10^2^-29`で`71`、9の補数は`10^2^-29-1`で`70`となります。10進法での10の補数をもうすこしわかりやすく説明すると、次の位の最小値100から29を引いた数ということです。

次に4ビットの2進法での`1001`の2の補数を考えてみましょう。`1001`は10進法で`9`なので`2^4^-9`で`7`、つまり2進法では`0111`が2の補数となります。1の補数は`2^4^-9-1`で6、つまり`0110`が1の補数となります。

また、この定義から2の補数と1の補数はより簡単に求められることがわかります。

- 1の補数は次のビット列の最小値からの差、つまり各ビット列を反転したものである
- 2の補数は1の補数`+1`である



[[signed-number]]
== 符号付数値表現

二進数で負の数をあらわす場合、もっとも左のビット列の数値を負の値にすることで表現されます。

ではなぜ負の表現に2の補数を利用するのかを4ビットの二進法で考えてみましょう。


[cols="1,1,1a,1a"]
|===
|n(10進法)|n(2進法)|nの2の補数|nとnの2の補数の合計

|0
|0000
|[line-through]##1##0000
|[line-through]##1##0000

|1
|0001
|1111
|[line-through]##1##0000

|3
|0011
|1101
|[line-through]##1##0000

|7
|0111
|1001
|[line-through]##1##0000

|15
|1111
|0001
|[line-through]##1##0000
|===

この表から2進数nとその補数の合計は常に同じであり、さらにこの和は常に`0000`であることがわかります。このことから、nの2の補数を-n(10進法)とすると定義する都合がよさそうです。

しかし、そうすると`1111`が`15`でもあり`-1`でもあることになってしまいます。そこで3番目のビット列が`0`のときを正、`1`のときを負にするという定義を追加することで重複を解消するのです。

さて、これをふまえたうえで、先ほどの問題に戻ってみましょう。

[source,js]
----
console.log(~~parseInt("01111111111111111111111111111111",2)); // 2147483647
console.log(~~parseInt("11111111111111111111111111111111",2)); // これは何になる？
----

これが`-2147483647`にならないのは明白です。

実際にこの数値が十進法でいくつかを考えるには、定義により成り立つ次の式で求めることができます。

[source,js]
----
var x = ~~parseInt("00000000000000000000000000000001",2); // 1
console.log(~~parseInt("11111111111111111111111111111111",2) + x)； // 0
----

この式から`~~parseInt("11111111111111111111111111111111",2)`は`-1`であることがわかります。



[[bit-shift]]
== ビットシフト

次はビットシフトについてです。ビットシフトは二進法で表した数値をずらし、空いたビット列には`0`を埋めます。

[cols="2a,3,1,6"]
|===
|コード|二進法|十進法|説明

|`12`
|00000000000000000000000000001100
|12
|

|`-12`
|11111111111111111111111111110100
|-12
|

|`12 << 1`
|00000000000000000000000000011000
|24
.3+|ビットを指定された数だけ左にずらします。これは左オペランドを`x`右オペランドを`y`とすると、`x*(2^y)`と同様の結果になります。

|`12 << 2`
|00000000000000000000000000110000
|48

|`12 << 3`
|00000000000000000000000001100000
|96

|`12 >> 1`
|00000000000000000000000000000110
|6
.4+|ビットを指定された数だけ右にずらします。ただし符号は維持されます。これは左オペランドを`x`右オペランドを`y`とすると、`x/(2^y)`と同様の結果になります。

|`12 >> 2`
|00000000000000000000000000000011
|3

|`12 >> 3`
|00000000000000000000000000000001
|1

|`-12 >> 1`
|11111111111111111111111111111010
|-6

|`-12 >>> 1`
|01111111111111111111111111111010
|2147483642
|ビットを指定された数だけ右にずらします。ただし符号は維持しません。
|===



[[application]]
== ビット演算の応用例

XorshiftはGeorge Marsagliaが開発したビット演算を利用した擬似乱数生成法の1つです。JavaScriptでは次のように実装されます。

[source,js]
----
var xor128 = {
  x: 123456789,
  y: 362436069,
  z: 521288629,
  w: 88675123,

  setSeed: function(seed){
      this.w = seed;
  },

  generate: function() {
      var t  = this.x ^ (this.x << 11);
      this.x = this.y;
      this.y = this.z;
      this.z = this.w;
      this.w = this.w ^ (this.w >> 19) ^ (t ^ (t >> 8));

      return this.w;
  }
};
----

実際に試してみる場合には、次のコードを入力してみてください。コンソールに数値が出力されているはずです。

[source,js]
----
var obj = Object.create(xor128);
obj.setSeed(100);
console.log(obj.generate());
----

もう少しシンプルな利用例では奇数と偶数の判別があります。

[source,js]
----
if(num&1 === 0){
  // これは偶数
}else{
  // 残りは奇数
}
----

`num&1`が`0`であれば偶数になるのはなぜでしょうか。

偶数である条件が最も右のビット列が`0`であるということは、最も右のビット列以外が2の倍数で表現されていることから明白です。`&`はどちらも`1`ならば`1`、そうでなければ`0`になるので`num&1`とすることで、最も右のビット列以外の全てのビット列を`0`にし、かつ右のビット列の状態だけを残すことができるのです。

4ビットで考えると次のようになります。

|===
|10進法n|2進法n|0001|n&1

|0
|0000
|0001
|0000

|1
|0001
|0001
|0001

|14
|1111
|1110
|0000

|15
|1111
|0001
|0001
|===



[[bibliography]]
== 参照文献

[bibliography]
- http://www.jstatsoft.org/v08/i14/[Xorshift RNGs]
